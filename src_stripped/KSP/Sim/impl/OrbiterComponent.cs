// Decompiled with JetBrains decompiler
// Type: KSP.Sim.impl.OrbiterComponent
// Assembly: Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 0F37EC74-8184-4DF6-B7AF-AB13D81C547A
// Assembly location: C:\KSP2\DLL_stripped\Assembly-CSharp-stripped.dll
// XML documentation location: C:\KSP2\DLL_stripped\Assembly-CSharp-stripped.xml

using KSP.Api;
using KSP.Sim.Converters;
using KSP.Sim.Definitions;
using KSP.Sim.State;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace KSP.Sim.impl
{
  public class OrbiterComponent : ObjectComponent, IPositionDriver, ILinearMotionDriver
  {
    public const int MAX_NBODY_ORBITS = 10;
    private double _lastKnownPeriapsis;
    private double _warpCollisionRecalculateThreshhold;
    private double _collisionUT;
    private bool _isConverged;
    private bool _collisionPathNotified;
    private bool isStable;
    private IUniverseModel universeModel;

    [TypeConverterIgnore]
    public override System.Type Type
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
    }

    [TypeConverterIgnore]
    public override System.Type DefinitionType
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
    }

    [TypeConverterIgnore]
    public override System.Type StateType
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
    }

    public Color orbitColor
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
      [MethodImpl(MethodImplOptions.NoInlining)] private set => throw null;
    }

    public Color nodeColor
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
      [MethodImpl(MethodImplOptions.NoInlining)] private set => throw null;
    }

    public float lowerCamVsSmaRatio
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
      [MethodImpl(MethodImplOptions.NoInlining)] private set => throw null;
    }

    public float upperCamVsSmaRatio
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
      [MethodImpl(MethodImplOptions.NoInlining)] private set => throw null;
    }

    /// <summary>The current patch for this OrbiterComponent.</summary>
    [TypeConverterIgnore]
    public PatchedConicsOrbit PatchedConicsOrbit
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
    }

    /// <summary>The list of patches generated by ManeuverPlanSolver.</summary>
    [TypeConverterIgnore]
    public List<PatchedNBodyOrbit> PatchedNBodyOrbits
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
    }

    /// <summary>The current patch for this OrbiterComponent.</summary>
    [TypeConverterIgnore]
    public IPatchedOrbit PatchedOrbit
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
      [MethodImpl(MethodImplOptions.NoInlining)] set => throw null;
    }

    /// <summary>
    /// The reverse flag for this OrbiterComponent. If true, the orbit progresses retrograde?
    /// </summary>
    [TypeConverterIgnore]
    public bool reverse
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
    }

    /// <summary>
    /// The action triggered when this OrbiterComponent's state has been updated. See UpdatePosition, UpdateVelocity, and UpdateFromStateVectors.
    /// </summary>
    public event Action<IKeplerOrbit> OrbitalStateUpdated
    {
      [MethodImpl(MethodImplOptions.NoInlining)] add => throw null;
      [MethodImpl(MethodImplOptions.NoInlining)] remove => throw null;
    }

    /// <summary>
    /// The action triggered when the reference body changes, e.g. when transitioning across an SOI boundary.
    /// </summary>
    public event Action<OrbiterComponent, CelestialBodyComponent> OnReferenceBodyChange
    {
      [MethodImpl(MethodImplOptions.NoInlining)] add => throw null;
      [MethodImpl(MethodImplOptions.NoInlining)] remove => throw null;
    }

    /// <summary>The PatchedConicSolver for this OrbiterComponent.</summary>
    [TypeConverterIgnore]
    public PatchedConicSolver PatchedConicSolver
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
      [MethodImpl(MethodImplOptions.NoInlining)] set => throw null;
    }

    /// <summary>The ManeuverPlanSolver for this OrbiterComponent.</summary>
    [TypeConverterIgnore]
    public ManeuverPlanSolver ManeuverPlanSolver
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
      [MethodImpl(MethodImplOptions.NoInlining)] set => throw null;
    }

    /// <summary>The OrbitTargeter for this OrbiterComponent.</summary>
    [TypeConverterIgnore]
    public OrbitTargeter OrbitTargeter
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
      [MethodImpl(MethodImplOptions.NoInlining)] set => throw null;
    }

    /// <summary>The coordinate system for this OrbiterComponent.</summary>
    [TypeConverterIgnore]
    public ICoordinateSystem coordinateSystem
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
    }

    /// <summary>The current local position for this OrbiterComponent.</summary>
    [TypeConverterIgnore]
    public Vector3d localPosition
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
    }

    /// <summary>The current relative motion for this OrbiterComponent.</summary>
    [TypeConverterIgnore]
    public IMotion relativeToMotion
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
    }

    /// <summary>The current relative velocity for this OrbiterComponent.</summary>
    [TypeConverterIgnore]
    public Vector relativeVelocity
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
    }

    /// <summary>The Position structure for this OrbiterComponent.</summary>
    [TypeConverterIgnore]
    public Position Position
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
    }

    /// <summary>
    /// Updates the Position structure for this OrbiterComponent. To update both position and velocity use UpdateFromStateVectors.
    /// </summary>
    /// <param name="newPosition"></param>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public void UpdatePosition(Position newPosition) => throw null;

    /// <summary>The action triggered when the position is updated.</summary>
    public event Action<Position> PositionUpdated
    {
      [MethodImpl(MethodImplOptions.NoInlining)] add => throw null;
      [MethodImpl(MethodImplOptions.NoInlining)] remove => throw null;
    }

    /// <summary>The Velocity structure for this OrbiterComponent.</summary>
    [TypeConverterIgnore]
    public Velocity Velocity
    {
      [MethodImpl(MethodImplOptions.NoInlining)] get => throw null;
    }

    /// <summary>
    /// Updates the Velocity structure for this OrbiterComponent. To update both position and velocity use UpdateFromStateVectors
    /// </summary>
    /// <param name="newVelocity"></param>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public void UpdateVelocity(Velocity newVelocity) => throw null;

    /// <summary>The action triggered when the velocity is updated</summary>
    public event Action<Velocity> VelocityUpdated
    {
      [MethodImpl(MethodImplOptions.NoInlining)] add => throw null;
      [MethodImpl(MethodImplOptions.NoInlining)] remove => throw null;
    }

    /// <summary>
    /// Updates both the Position structure and Velocity structure for this OrbiterComponent. To update only position or velocity use either UpdatePosition or UpdateVelocity respectively.
    /// </summary>
    /// <param name="newPosition"></param>
    /// <param name="newVelocity"></param>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public void UpdateFromStateVectors(Position newPosition, Velocity newVelocity) => throw null;

    /// <summary>Configures a (new) (blank?) OrbiterComponent.</summary>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public OrbiterComponent() => throw null;

    /// <summary>Configures a (new) OrbiterComponent using the supplied universeModel.</summary>
    /// <param name="universeModel"></param>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public OrbiterComponent(UniverseModel universeModel) => throw null;

    /// <summary>
    /// Configures a (new) OrbiterComponent using the supplied orbiterDefinition and universeModel.
    /// </summary>
    /// <param name="orbiterDefinition"></param>
    /// <param name="universeModel"></param>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public OrbiterComponent(OrbiterDefinition orbiterDefinition, IUniverseModel universeModel) => throw null;

    /// <summary>
    /// Returns the orbiterDefinition object for this OrbiterComponent.
    /// </summary>
    /// <returns orbiterDefinition></returns>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public override object GetDefinition() => throw null;

    /// <summary>
    /// Returns the stateData object for this OrbiterComponent.
    /// </summary>
    /// <returns stateData></returns>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public override object GetState() => throw null;

    /// <summary>
    /// Validates the stateData for this OrbiterComponent using the supplied simulationModelMap. Returns true if valid and false otherwise.
    /// </summary>
    /// <param name="stateData"></param>
    /// <param name="simulationModelMap"></param>
    /// <returns pass></returns>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public override bool ValidateState(object stateData, ISimulationModelMap simulationModelMap) => throw null;

    /// <summary>
    /// Sets the stateData for this OrbiterComponent using the supplied simulationModelMap. Returns true if the state was successfulle set and false otherwise.
    /// </summary>
    /// <param name="stateData"></param>
    /// <param name="simulationModelMap"></param>
    /// <returns pass></returns>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public override object SetState(object stateData, ISimulationModelMap simulationModelMap) => throw null;

    /// <summary>
    /// Sets the stateData for this OrbiterComponent using the supplied KeplerOrbitState, universalTime, and simulationModelMap.
    /// </summary>
    /// <param name="state"></param>
    /// <param name="universalTime"></param>
    /// <param name="simulationModelMap"></param>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public void SetState(
      KeplerOrbitState state,
      double universalTime,
      ISimulationModelMap simulationModelMap)
    {
      throw null;
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="universalTime"></param>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public override void OnStart(double universalTime) => throw null;

    /// <summary>
    /// 
    /// </summary>
    /// <param name="simObject"></param>
    /// <param name="universalTime"></param>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public override void OnRemoved(SimulationObjectModel simObject, double universalTime) => throw null;

    /// <summary>
    /// 
    /// </summary>
    /// <param name="universalTime"></param>
    /// <param name="deltaUniversalTime"></param>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public override void OnFixedUpdate(double universalTime, double deltaUniversalTime) => throw null;

    /// <summary>
    /// Updates this OrbiterComponent from parameters at the supplied universalTime? Confirm and update documentation as needed.
    /// </summary>
    /// <param name="universalTime"></param>
    [MethodImpl(MethodImplOptions.NoInlining)]
    private void UpdateFromParameters(double universalTime) => throw null;

    /// <summary>Checks the orbital stability for this OrbiterComponent.</summary>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public void CheckOrbitStability() => throw null;

    /// <summary>
    /// Checks for object collisions (for?/with?) inactive vessel(s?). Confirm and update documentation please.
    /// </summary>
    /// <param name="collisionTolerance"></param>
    [MethodImpl(MethodImplOptions.NoInlining)]
    private void CheckInactiveVesselCollision(double collisionTolerance) => throw null;

    /// <summary>No clue. Please investigate and update</summary>
    /// <param name="patch"></param>
    /// <param name="collisionTolerance"></param>
    /// <param name="referenceBodyHeight"></param>
    [MethodImpl(MethodImplOptions.NoInlining)]
    private void onRailsCollision(
      PatchedConicsOrbit patch,
      double collisionTolerance,
      double referenceBodyHeight)
    {
      throw null;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static bool PredictSoiTransfer(
      in IPatchedOrbit startPatch,
      double currentUT,
      double deltaUT,
      out double timeToSoiEncounter)
    {
      throw null;
    }
  }
}
